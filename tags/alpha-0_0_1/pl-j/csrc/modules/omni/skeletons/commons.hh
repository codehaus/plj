// This file is generated by omniidl (C++ backend)- omniORB_4_0. Do not edit.
#ifndef __commons_hh__
#define __commons_hh__

#ifndef USE_omniORB_logStream
#define USE_omniORB_logStream
#endif

#ifndef __CORBA_H_EXTERNAL_GUARD__
#include <omniORB4/CORBA.h>
#endif

#ifndef  USE_core_stub_in_nt_dll
# define USE_core_stub_in_nt_dll_NOT_DEFINED_commons
#endif
#ifndef  USE_dyn_stub_in_nt_dll
# define USE_dyn_stub_in_nt_dll_NOT_DEFINED_commons
#endif





#ifdef USE_stub_in_nt_dll
#ifndef USE_core_stub_in_nt_dll
#define USE_core_stub_in_nt_dll
#endif
#ifndef USE_dyn_stub_in_nt_dll
#define USE_dyn_stub_in_nt_dll
#endif
#endif

#ifdef _core_attr
# error "A local CPP macro _core_attr has already been defined."
#else
# ifdef  USE_core_stub_in_nt_dll
#  define _core_attr _OMNIORB_NTDLL_IMPORT
# else
#  define _core_attr
# endif
#endif

#ifdef _dyn_attr
# error "A local CPP macro _dyn_attr has already been defined."
#else
# ifdef  USE_dyn_stub_in_nt_dll
#  define _dyn_attr _OMNIORB_NTDLL_IMPORT
# else
#  define _dyn_attr
# endif
#endif





_CORBA_MODULE org

_CORBA_MODULE_BEG

  _CORBA_MODULE pgj

  _CORBA_MODULE_BEG

    _CORBA_MODULE corba

    _CORBA_MODULE_BEG

      class raw_var;

      class raw : public _CORBA_Unbounded_Sequence_Char {
      public:
        typedef raw_var _var_type;
        inline raw() {}
        inline raw(const raw& _s)
          : _CORBA_Unbounded_Sequence_Char(_s) {}

        inline raw(_CORBA_ULong _max)
          : _CORBA_Unbounded_Sequence_Char(_max) {}
        inline raw(_CORBA_ULong _max, _CORBA_ULong _len, CORBA::Char* _val, _CORBA_Boolean _rel=0)
          : _CORBA_Unbounded_Sequence_Char(_max, _len, _val, _rel) {}

      

        inline raw& operator = (const raw& _s) {
          _CORBA_Unbounded_Sequence_Char::operator=(_s);
          return *this;
        }
      };

      class raw_out;

      class raw_var {
      public:
        inline raw_var() : _pd_seq(0) {}
        inline raw_var(raw* _s) : _pd_seq(_s) {}
        inline raw_var(const raw_var& _s) {
          if( _s._pd_seq )  _pd_seq = new raw(*_s._pd_seq);
          else              _pd_seq = 0;
        }
        inline ~raw_var() { if( _pd_seq )  delete _pd_seq; }
          
        inline raw_var& operator = (raw* _s) {
          if( _pd_seq )  delete _pd_seq;
          _pd_seq = _s;
          return *this;
        }
        inline raw_var& operator = (const raw_var& _s) {
          if( _s._pd_seq ) {
            if( !_pd_seq )  _pd_seq = new raw;
            *_pd_seq = *_s._pd_seq;
          } else if( _pd_seq ) {
            delete _pd_seq;
            _pd_seq = 0;
          }
          return *this;
        }
        inline CORBA::Char& operator [] (_CORBA_ULong _s) {
          return (*_pd_seq)[_s];
        }

      

        inline raw* operator -> () { return _pd_seq; }
#if defined(__GNUG__)
        inline operator raw& () const { return *_pd_seq; }
#else
        inline operator const raw& () const { return *_pd_seq; }
        inline operator raw& () { return *_pd_seq; }
#endif
          
        inline const raw& in() const { return *_pd_seq; }
        inline raw&       inout()    { return *_pd_seq; }
        inline raw*&      out() {
          if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
          return _pd_seq;
        }
        inline raw* _retn() { raw* tmp = _pd_seq; _pd_seq = 0; return tmp; }
          
        friend class raw_out;
        
      private:
        raw* _pd_seq;
      };

      class raw_out {
      public:
        inline raw_out(raw*& _s) : _data(_s) { _data = 0; }
        inline raw_out(raw_var& _s)
          : _data(_s._pd_seq) { _s = (raw*) 0; }
        inline raw_out(const raw_out& _s) : _data(_s._data) {}
        inline raw_out& operator = (const raw_out& _s) {
          _data = _s._data;
          return *this;
        }
        inline raw_out& operator = (raw* _s) {
          _data = _s;
          return *this;
        }
        inline operator raw*&()  { return _data; }
        inline raw*& ptr()       { return _data; }
        inline raw* operator->() { return _data; }

        inline CORBA::Char& operator [] (_CORBA_ULong _i) {
          return (*_data)[_i];
        }

      

        raw*& _data;

      private:
        raw_out();
        raw_out& operator=(const raw_var&);
      };

      struct type_value_pair {
        typedef _CORBA_ConstrType_Variable_Var<type_value_pair> _var_type;

        
        CORBA::String_member _cxx_typename;

        CORBA::Boolean isnull;

        raw value;

      

        void operator>>= (cdrStream &) const;
        void operator<<= (cdrStream &);
      };

      typedef type_value_pair::_var_type type_value_pair_var;

      typedef _CORBA_ConstrType_Variable_OUT_arg< type_value_pair,type_value_pair_var > type_value_pair_out;

    _CORBA_MODULE_END

  _CORBA_MODULE_END

_CORBA_MODULE_END



_CORBA_MODULE POA_org
_CORBA_MODULE_BEG

  _CORBA_MODULE pgj
  _CORBA_MODULE_BEG

    _CORBA_MODULE corba
    _CORBA_MODULE_BEG

    _CORBA_MODULE_END

  _CORBA_MODULE_END

_CORBA_MODULE_END





#undef _core_attr
#undef _dyn_attr





#ifdef   USE_core_stub_in_nt_dll_NOT_DEFINED_commons
# undef  USE_core_stub_in_nt_dll
# undef  USE_core_stub_in_nt_dll_NOT_DEFINED_commons
#endif
#ifdef   USE_dyn_stub_in_nt_dll_NOT_DEFINED_commons
# undef  USE_dyn_stub_in_nt_dll
# undef  USE_dyn_stub_in_nt_dll_NOT_DEFINED_commons
#endif

#endif  // __commons_hh__

